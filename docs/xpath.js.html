<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>xpath.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AttlistDecl.html">AttlistDecl</a><ul class='methods'><li data-type='method'><a href="AttlistDecl.html#add">add</a></li><li data-type='method'><a href="AttlistDecl.html#descendantElements">descendantElements</a></li><li data-type='method'><a href="AttlistDecl.html#descendants">descendants</a></li><li data-type='method'><a href="AttlistDecl.html#elements">elements</a></li><li data-type='method'><a href="AttlistDecl.html#text">text</a></li><li data-type='method'><a href="AttlistDecl.html#toString">toString</a></li></ul></li><li><a href="Attribute.html">Attribute</a><ul class='methods'><li data-type='method'><a href="Attribute.html#first">first</a></li><li data-type='method'><a href="Attribute.html#get">get</a></li><li data-type='method'><a href="Attribute.html#text">text</a></li><li data-type='method'><a href="Attribute.html#toString">toString</a></li></ul></li><li><a href="AttributeDecl.html">AttributeDecl</a><ul class='methods'><li data-type='method'><a href="AttributeDecl.html#first">first</a></li><li data-type='method'><a href="AttributeDecl.html#get">get</a></li><li data-type='method'><a href="AttributeDecl.html#text">text</a></li><li data-type='method'><a href="AttributeDecl.html#toString">toString</a></li></ul></li><li><a href="CdataSection.html">CdataSection</a><ul class='methods'><li data-type='method'><a href="CdataSection.html#add">add</a></li><li data-type='method'><a href="CdataSection.html#descendantElements">descendantElements</a></li><li data-type='method'><a href="CdataSection.html#descendants">descendants</a></li><li data-type='method'><a href="CdataSection.html#elements">elements</a></li><li data-type='method'><a href="CdataSection.html#text">text</a></li><li data-type='method'><a href="CdataSection.html#toString">toString</a></li></ul></li><li><a href="Comment.html">Comment</a><ul class='methods'><li data-type='method'><a href="Comment.html#first">first</a></li><li data-type='method'><a href="Comment.html#get">get</a></li><li data-type='method'><a href="Comment.html#text">text</a></li><li data-type='method'><a href="Comment.html#toString">toString</a></li></ul></li><li><a href="DoctypeDecl.html">DoctypeDecl</a><ul class='methods'><li data-type='method'><a href="DoctypeDecl.html#add">add</a></li><li data-type='method'><a href="DoctypeDecl.html#descendantElements">descendantElements</a></li><li data-type='method'><a href="DoctypeDecl.html#descendants">descendants</a></li><li data-type='method'><a href="DoctypeDecl.html#elements">elements</a></li><li data-type='method'><a href="DoctypeDecl.html#text">text</a></li><li data-type='method'><a href="DoctypeDecl.html#toString">toString</a></li></ul></li><li><a href="Document.html">Document</a><ul class='methods'><li data-type='method'><a href="Document.html#add">add</a></li><li data-type='method'><a href="Document.html#descendantElements">descendantElements</a></li><li data-type='method'><a href="Document.html#descendants">descendants</a></li><li data-type='method'><a href="Document.html#elements">elements</a></li><li data-type='method'><a href="Document.html#first">first</a></li><li data-type='method'><a href="Document.html#get">get</a></li><li data-type='method'><a href="Document.html#text">text</a></li><li data-type='method'><a href="Document.html#toString">toString</a></li></ul></li><li><a href="DomParser.html">DomParser</a><ul class='methods'><li data-type='method'><a href="DomParser.html#destroy">destroy</a></li><li data-type='method'><a href="DomParser.html#parse">parse</a></li><li data-type='method'><a href="DomParser.html#.fromString">fromString</a></li><li data-type='method'><a href="DomParser.html#.parseFull">parseFull</a></li></ul></li><li><a href="Element.html">Element</a><ul class='methods'><li data-type='method'><a href="Element.html#add">add</a></li><li data-type='method'><a href="Element.html#attribute">attribute</a></li><li data-type='method'><a href="Element.html#descendantElements">descendantElements</a></li><li data-type='method'><a href="Element.html#descendants">descendants</a></li><li data-type='method'><a href="Element.html#element">element</a></li><li data-type='method'><a href="Element.html#elements">elements</a></li><li data-type='method'><a href="Element.html#removeAttribute">removeAttribute</a></li><li data-type='method'><a href="Element.html#setAttribute">setAttribute</a></li><li data-type='method'><a href="Element.html#text">text</a></li><li data-type='method'><a href="Element.html#toString">toString</a></li></ul></li><li><a href="ElementDecl.html">ElementDecl</a><ul class='methods'><li data-type='method'><a href="ElementDecl.html#first">first</a></li><li data-type='method'><a href="ElementDecl.html#get">get</a></li><li data-type='method'><a href="ElementDecl.html#text">text</a></li><li data-type='method'><a href="ElementDecl.html#toString">toString</a></li></ul></li><li><a href="EntityDecl.html">EntityDecl</a><ul class='methods'><li data-type='method'><a href="EntityDecl.html#first">first</a></li><li data-type='method'><a href="EntityDecl.html#get">get</a></li><li data-type='method'><a href="EntityDecl.html#text">text</a></li><li data-type='method'><a href="EntityDecl.html#toString">toString</a></li></ul></li><li><a href="Namespace.html">Namespace</a><ul class='methods'><li data-type='method'><a href="Namespace.html#first">first</a></li><li data-type='method'><a href="Namespace.html#get">get</a></li><li data-type='method'><a href="Namespace.html#text">text</a></li><li data-type='method'><a href="Namespace.html#toString">toString</a></li></ul></li><li><a href="Namespace_Namespace.html">Namespace</a></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method'><a href="Node.html#first">first</a></li><li data-type='method'><a href="Node.html#get">get</a></li><li data-type='method'><a href="Node.html#text">text</a></li><li data-type='method'><a href="Node.html#toString">toString</a></li><li data-type='method'><a href="Node.html#.escape">escape</a></li></ul></li><li><a href="NotationDecl.html">NotationDecl</a><ul class='methods'><li data-type='method'><a href="NotationDecl.html#first">first</a></li><li data-type='method'><a href="NotationDecl.html#get">get</a></li><li data-type='method'><a href="NotationDecl.html#text">text</a></li><li data-type='method'><a href="NotationDecl.html#toString">toString</a></li></ul></li><li><a href="ParentNode.html">ParentNode</a><ul class='methods'><li data-type='method'><a href="ParentNode.html#add">add</a></li><li data-type='method'><a href="ParentNode.html#descendantElements">descendantElements</a></li><li data-type='method'><a href="ParentNode.html#descendants">descendants</a></li><li data-type='method'><a href="ParentNode.html#elements">elements</a></li><li data-type='method'><a href="ParentNode.html#text">text</a></li><li data-type='method'><a href="ParentNode.html#toString">toString</a></li></ul></li><li><a href="ProcessingInstruction.html">ProcessingInstruction</a><ul class='methods'><li data-type='method'><a href="ProcessingInstruction.html#first">first</a></li><li data-type='method'><a href="ProcessingInstruction.html#get">get</a></li><li data-type='method'><a href="ProcessingInstruction.html#text">text</a></li><li data-type='method'><a href="ProcessingInstruction.html#toString">toString</a></li></ul></li><li><a href="Text.html">Text</a><ul class='methods'><li data-type='method'><a href="Text.html#first">first</a></li><li data-type='method'><a href="Text.html#get">get</a></li><li data-type='method'><a href="Text.html#text">text</a></li><li data-type='method'><a href="Text.html#toString">toString</a></li></ul></li><li><a href="XPath.html">XPath</a><ul class='methods'><li data-type='method'><a href="XPath.html#execute">execute</a></li></ul></li><li><a href="XPathSyntaxError.html">XPathSyntaxError</a></li><li><a href="XmlDeclaration.html">XmlDeclaration</a><ul class='methods'><li data-type='method'><a href="XmlDeclaration.html#first">first</a></li><li data-type='method'><a href="XmlDeclaration.html#get">get</a></li><li data-type='method'><a href="XmlDeclaration.html#text">text</a></li><li data-type='method'><a href="XmlDeclaration.html#toString">toString</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-ConstructorParameters.html">ConstructorParameters</a></li><li><a href="external-Exclude.html">Exclude</a></li><li><a href="external-Extract.html">Extract</a></li><li><a href="external-InstanceType.html">InstanceType</a></li><li><a href="external-NonNullable.html">NonNullable</a></li><li><a href="external-Omit.html">Omit</a></li><li><a href="external-OmitThisParameter.html">OmitThisParameter</a></li><li><a href="external-Parameters.html">Parameters</a></li><li><a href="external-Partial.html">Partial</a></li><li><a href="external-Pick.html">Pick</a></li><li><a href="external-Readonly.html">Readonly</a></li><li><a href="external-Record.html">Record</a></li><li><a href="external-Required.html">Required</a></li><li><a href="external-ReturnType.html">ReturnType</a></li><li><a href="external-ThisParameterType.html">ThisParameterType</a></li><li><a href="external-ThisType.html">ThisType</a></li></ul><h3><a href="global.html">Global</a></h3>
    
</nav>

<div id="main">
    
    <h1 class="page-title">xpath.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as dom from './dom.js'
import * as grammar from './xpathPattern3.js'
import util from 'util'

/**
 * Error parsing an XPath expression, with prettier output.
 *
 * @extends {Error}
 */
export class XPathSyntaxError extends Error {
  /**
   * Creates an instance of XPathSyntaxError.
   *
   * @param {Error} e Error thrown from peg parser
   * @param {string} pattern The pattern that was being parsed
   */
  constructor(e, pattern) {
    super(`Syntax error in "${pattern}": ${e.message}`, {cause: e})
    this.pattern = pattern
    // @ts-ignore
    if (e.location) {
      // @ts-ignore
      this.location = e.location
    }
  }

  /**
   * Format the error for the console.
   *
   * @param {number} depth How deep can we go?  0 to stop.
   * @param {util.InspectOptionsStylized} options Inspection options
   * @returns {string}
   */
  [util.inspect.custom](depth, options) {
    if (!options.colors || !options.stylize) {
      return this.toString()
    }
    let ret = 'Error: '
    ret += this.pattern.slice(0, this.location.start.offset)
    ret += options.stylize(this.pattern.slice(this.location.start.offset, this.location.end.offset), 'regexp')
    ret += this.pattern.slice(this.location.end.offset)
    return ret
  }
}

/**
 * @typedef {Array&lt;string|dom.Node>} XPathResult
 */

/**
 * An XPath expression for querying an XML document
 */
export class XPath {
  /**
   * Creates an instance of XPath.
   *
   * @param {string} pattern
   * @throws {TypeError} Not a string
   * @throws {XPathSyntaxError} Invalid syntax in the pattern
   */
  constructor(pattern) {
    if (typeof pattern !== 'string') {
      throw new TypeError('pattern required')
    }
    this.pattern = pattern
    try {
      this.start = grammar.parse(pattern, {
        impl: this,
      })
    } catch (e) {
      throw new XPathSyntaxError(/** @type {Error} */(e), pattern)
    }
  }

  /**
   * Staring with the given context Node, execute the expression
   *
   * @param {dom.Node} context The DOM Node from which to base the expression's
   *   query
   * @returns {XPathResult} resuts
   */
  execute(context) {
    return this._eval([context], this.start)
  }

  /**
   * @callback OpFunction
   * @param {number} i The offset into the context nodes list
   * @param {dom.Node} context The current context node
   * @param {...any} args Extra arguments for the function
   * @returns {XPathResult}
   * @private
   */

  /**
   * @jsdoc-remove-next-tag
   * @typedef {[OpFunction, ...any]} Functor
   */

  /**
   * Evaluate a function within some nodes, concatenating the results.
   *
   * @param {dom.Node[]} context
   * @param {Functor} functor The function and extra arguments to
   *   call on each node in context
   * @returns {XPathResult}
   * @private
   */
  _eval(context, [func, ...args]) {
    if (typeof func !== 'function') {
      return [func, ...args]
    }
    return context.reduce(
      (p, c, i) => {
        const eret = func.call(this, i, c, ...args)
        return p.concat(eret)
      }, /** @type {XPathResult} */([])
    )
  }

  /**
   * Get the root node of the doc
   *
   * @param {number} num Unused
   * @param {dom.Node} context What node to start from
   * @param {Functor} [relative] Query to run relative to root
   * @returns {XPathResult}
   * @private
   */
  _root(num, context, relative) {
    const doc = context &amp;&amp; context.document
    if (doc) {
      if (relative) {
        return this._eval([doc], relative)
      }
      return [doc]
    }
    return []
  }

  /**
   * Child elements with the given name.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @param {string} name
   * @returns {XPathResult}
   * @private
   */
  _nameTest(num, context, name) {
    if (Array.isArray(context)) {
      // Results of _all
      return context.filter(
        n => (n instanceof dom.Element) &amp;&amp; n.name.local === name
      )
    } else if (context instanceof dom.Document) {
      return [...context.elements(name)]
    } else if (context instanceof dom.Element) {
      return [...context.elements(name)]
    } else if (context instanceof dom.Attribute) {
      if (context.name.local === name) {
        return [context]
      }
    }
    return []
  }

  /**
   * All children, with "star".
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @param {string} star Should always be "*" for now.
   * @returns {XPathResult}
   * @private
   */
  _nameTestWildcard(num, context, star) {
    /* c8 ignore next */
    if (star !== '*') {
      throw new Error(`Unimplemented wildcard: "${star}"`)
    }
    if (Array.isArray(context)) {
      return context
    } else if (context instanceof dom.Attribute) {
      return [context]
    } else if (context instanceof dom.Element) {
      return [...context.elements()]
    } else if (context instanceof dom.Document) {
      const {root} = context
      if (!root) {
        throw new Error('Invalid document')
      }
      return [root]
    }
    return []
  }

  /**
   * Relative to the given context
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @param {Functor} first First chunk of relative chain
   * @param {Functor[]} steps
   * @returns {XPathResult}
   * @private
   */
  _relative(num, context, first, steps) {
    return steps.reduce(
      (prevContext, step) => this._eval(
        /** @type {dom.Node[]} */ (prevContext), step
      ),
      this._eval([context], first)
    )
  }

  /**
   * Single- or double-slash steps.
   *
   * @param {number} num Unused
   * @param {dom.Node} context Parent
   * @param {"/"|"//"} slash Single or double?
   * @param {Functor} expr RHS
   * @returns {XPathResult}
   * @private
   */
  _step(num, context, slash, expr) {
    if (slash === '//') {
      if (!(context instanceof dom.ParentNode)) {
        throw new Error('Invalid parent node for //')
      }
      const descendants = [...context.descendantElements()]
      // @ts-ignore -- I don't understand this one
      return this._eval([descendants], expr)
    }
    return this._eval([context], expr)
  }

  /**
   * Attribute check
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @param {Functor} expr
   * @returns {XPathResult}
   * @private
   */
  _attrib(num, context, expr) {
    if (Array.isArray(context)) {
      return context.reduce((p, v) => {
        if (v instanceof dom.Element) {
          p = p.concat(this._eval(v.att, expr))
        }
        return p
      }, [])
    } else if (!(context instanceof dom.Element)) {
      throw new Error('Can only take attributes of elements')
    }
    return this._eval(context.att, expr)
  }

  /**
   * "//" at the beginning of the pattern.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @param {Functor} expr
   * @returns {XPathResult}
   * @private
   */
  _all(num, context, expr) {
    // Example:
    // (fn:root(self::node()) treat as
    //   document-node())/descendant-or-self::node()/
    if (!(context instanceof dom.ParentNode)) {
      throw new Error('Ivalid context for beginning //')
    }
    // @ts-ignore -- Don't understand this either
    return this._eval([[context, ...context.descendants()]], expr)
  }

  /**
   * Retrieve the text from the node.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @returns {XPathResult}
   * @private
   */
  _textTest(num, context) {
    if (!(context instanceof dom.ParentNode)) {
      throw new Error('Cannot get text from this node')
    }
    return [context.text()]
  }

  /**
   * The current node.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @returns {XPathResult}
   * @private
   */
  _dot(num, context) {
    return [context]
  }

  /**
   * Filter a list of nodes with a set of predicates.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @param {Functor} expr
   * @param {Functor[]} predicates
   * @returns {XPathResult}
   * @private
   */
  _filter(num, context, expr, predicates) {
    return predicates.reduce(
      (prevContext, pred) => this._eval(
        /** @type {dom.Node[]} */ (prevContext), pred
      ),
      this._eval([context], expr)
    )
  }

  /**
   *
   * @param {number} num Offset into the list one segment higher
   * @param {dom.Node} context
   * @param {number|Functor} expr
   * @returns {XPathResult}
   * @private
   */
  _pred(num, context, expr) {
    if (typeof expr === 'number') {
      return (expr === num + 1) ? [context] : []
    } else if (Array.isArray(expr)) {
      return (this._eval([context], expr).length > 0) ? [context] : []
    }
    /* istanbul ignore next */
    throw new Error(`Unimplemented predicate in "${this.pattern}": "${util.inspect(expr)}"`)
  }

  /**
   * Process an expression
   *
   * @param {dom.Node} context
   * @param {Functor} expr
   * @returns {string|dom.Node|undefined}
   * @private
   */
  _expr(context, expr) {
    if (Array.isArray(expr)) {
      const ret = this._eval([context], expr).shift()
      if (ret &amp;&amp; (ret instanceof dom.ParentNode)) {
        return ret.text()
      }
      return ret
    }
    return expr
  }

  /**
   * Compare left expression to right expression using operator op.
   *
   * @param {number} num
   * @param {dom.Node} context
   * @param {Functor} left
   * @param {string} op
   * @param {Functor} right
   * @returns {boolean[]}
   * @private
   */
  // eslint-disable-next-line max-params
  _compare(num, context, left, op, right) {
    const eLeft = this._expr(context, left)
    const eRight = this._expr(context, right)
    switch (op) {
      case '=':
      case 'eq':
        if (eLeft === eRight) {
          return [true]
        }
        break
      default:
        throw new Error(`Unimplemented op: "${op}"`)
    }
    return []
  }

  /**
   * Get the parent of the current node.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @returns {XPathResult}
   * @private
   */
  _parent(num, context) {
    if (Array.isArray(context)) {
      return context.reduce((p, v) => {
        if (v.parent) {
          p.push(v)
        }
        return p
      }, [])
    }
    if (!context.parent) {
      throw new Error('No parent')
    }
    return [context.parent]
  }

  /**
   * Comment in a pattern. Careful no-op.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @returns {XPathResult}
   * @private
   */
  _comment(num, context) {
    if (context instanceof dom.Comment) {
      return [context]
    } else if (Array.isArray(context)) {
      return context.filter(n => n instanceof dom.Comment)
    } else if (context instanceof dom.ParentNode) {
      return context.children.filter(n => n instanceof dom.Comment)
    }
    return []
  }

  /**
   * Multiple expressions in parallel.
   *
   * @param {number} num Unused
   * @param {dom.Node} context
   * @param {Functor[]} expressions
   * @returns {XPathResult}
   * @private
   */
  _comma(num, context, expressions) {
    return expressions.reduce(
      (p, v) => p.concat(this._eval([context], v)),
      /** @type {XPathResult} */ ([])
    )
  }

  /**
   * Some operation that hasn't been implemented yet.
   *
   * @param {number} num
   * @param {dom.Node} context
   * @param {string} op
   * @param  {...any} args
   * @private
   */
  _unimplemented(num, context, op, ...args) {
    throw new Error(`Unimplemented: "${op}"`)
    // Should this be an option?
    // console.error('UNIMPLEMENTED:', op)
    // return []
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
